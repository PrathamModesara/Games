<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Flappy Penguin 3D</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Three.js CDN for 3D rendering -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <style>
    body, html { height: 100%; margin: 0; overflow: hidden; }
    #game-canvas { display: block; margin: 0 auto; background: #e0f7fa; touch-action: none; }
    .overlay { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; }
    .ui { pointer-events: auto; }
    .mobile-controls { position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%); width: min(520px, 92vw); display: none; gap: 10px; pointer-events: auto; }
    .mobile-btn { flex: 1; background: rgba(14, 116, 144, 0.85); color: #fff; border-radius: 14px; padding: 14px 0; font-weight: 700; box-shadow: 0 8px 20px rgba(0,0,0,0.25); border: 2px solid rgba(255,255,255,0.35); }
    .mobile-btn:active { transform: scale(0.98); }
    @media (max-width: 768px) {
      #ui { width: 92vw; }
      #gameStatus { font-size: 1.4rem; }
      #hint { font-size: 0.95rem; }
      .mobile-controls { display: flex; }
      h1#title { font-size: 2.1rem; margin-top: 12px; margin-bottom: 12px; }
    }
  </style>
</head>
<body class="bg-blue-100">
  <div class="overlay flex flex-col items-center justify-start z-10">
    <div id="ui" class="ui mt-4 text-center">
      <h1 id="title" class="text-5xl font-extrabold text-white drop-shadow-lg mb-2 bg-gradient-to-r from-blue-500 to-cyan-400 px-6 py-2 rounded-2xl shadow-xl border-4 border-white">Flappy Penguin 3D</h1>
      <div id="hint" class="text-lg text-blue-100 mb-4 bg-blue-700/80 px-4 py-2 rounded-xl shadow-md transition-opacity duration-700">Desktop: Arrow Keys (← ↑ →). Mobile: Use the buttons.</div>
      <button id="restartBtn" class="hidden bg-gradient-to-r from-blue-500 to-cyan-400 hover:from-cyan-400 hover:to-blue-500 text-white font-bold py-2 px-6 rounded-xl shadow-lg mt-2">Restart</button>
      <div id="gameStatus" class="text-3xl font-bold mt-4 text-white drop-shadow-lg"></div>
    </div>
    <div class="mobile-controls" aria-label="Mobile controls">
      <button id="btnLeft" class="mobile-btn">Left</button>
      <button id="btnJump" class="mobile-btn">Jump</button>
      <button id="btnRight" class="mobile-btn">Right</button>
    </div>
  </div>
  <canvas id="game-canvas" class="rounded-3xl border-8 border-blue-300 shadow-2xl"></canvas>
  <script>
    // --- 3D Game Setup ---
    const canvas = document.getElementById('game-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setClearColor(0xe0f7fa, 1);
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xe0f7fa, 20, 100);

    // Camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 15);
    camera.lookAt(0, 0, 0);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    // Ground
    // Endless animated ground
    const groundGeo = new THREE.PlaneGeometry(40, 200, 40, 200);
    const groundMat = new THREE.MeshLambertMaterial({ color: 0xb3e5fc, side: THREE.DoubleSide });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -1.5;
    ground.receiveShadow = true;
    scene.add(ground);
    // Animate ground vertices for wave effect
    function animateGroundWave(frame) {
      const pos = ground.geometry.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        const ix = i % 41;
        const iz = Math.floor(i / 41);
        const origY = 0;
        pos.setY(i, origY + Math.sin((frame * 0.03 + ix * 0.3 + iz * 0.2)) * 0.12);
      }
      pos.needsUpdate = true;
      ground.geometry.computeVertexNormals();
    }

    // Penguin (simple 3D model)
    function createPenguin() {
      const group = new THREE.Group();
      // Body
      const bodyGeo = new THREE.SphereGeometry(0.7, 32, 32);
      const bodyMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      group.add(body);
      // Belly
      const bellyGeo = new THREE.SphereGeometry(0.5, 32, 32, 0, Math.PI * 2, 0, Math.PI / 1.5);
      const bellyMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
      const belly = new THREE.Mesh(bellyGeo, bellyMat);
      belly.position.z = 0.3;
      belly.position.y = -0.1;
      group.add(belly);
      // Beak
      const beakGeo = new THREE.ConeGeometry(0.15, 0.3, 16);
      const beakMat = new THREE.MeshLambertMaterial({ color: 0xffa726 });
      const beak = new THREE.Mesh(beakGeo, beakMat);
      beak.position.set(0, 0.1, 0.7);
      beak.rotation.x = Math.PI / 2;
      group.add(beak);
      // Eyes
      const eyeGeo = new THREE.SphereGeometry(0.07, 16, 16);
      const eyeMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
      const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
      leftEye.position.set(-0.2, 0.3, 0.6);
      const rightEye = leftEye.clone();
      rightEye.position.x = 0.2;
      group.add(leftEye, rightEye);
      // Flippers
      const flipperGeo = new THREE.BoxGeometry(0.1, 0.4, 0.2);
      const flipperMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
      const leftFlipper = new THREE.Mesh(flipperGeo, flipperMat);
      leftFlipper.position.set(-0.6, -0.2, 0);
      leftFlipper.rotation.z = Math.PI / 6;
      const rightFlipper = leftFlipper.clone();
      rightFlipper.position.x = 0.6;
      rightFlipper.rotation.z = -Math.PI / 6;
      group.add(leftFlipper, rightFlipper);
      // Feet
      const footGeo = new THREE.BoxGeometry(0.18, 0.08, 0.25);
      const footMat = new THREE.MeshLambertMaterial({ color: 0xffa726 });
      const leftFoot = new THREE.Mesh(footGeo, footMat);
      leftFoot.position.set(-0.18, -0.7, 0.18);
      const rightFoot = leftFoot.clone();
      rightFoot.position.x = 0.18;
      group.add(leftFoot, rightFoot);
      // Animation state
      group.userData = { squish: 0, jumpAnim: 0 };
      return group;
    }

    // Obstacles
    function createObstacle(type = 'block', color = 0xff5252) {
      let mesh;
      if (type === 'block') {
        const geo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
        const mat = new THREE.MeshPhysicalMaterial({ color, roughness: 0.5, metalness: 0.2 });
        mesh = new THREE.Mesh(geo, mat);
      } else if (type === 'cylinder') {
        const geo = new THREE.CylinderGeometry(0.7, 0.7, 2, 24);
        const mat = new THREE.MeshPhysicalMaterial({ color: 0xffb300, roughness: 0.3, metalness: 0.5 });
        mesh = new THREE.Mesh(geo, mat);
      } else if (type === 'moving') {
        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshPhysicalMaterial({ color: 0x7e57c2, roughness: 0.2, metalness: 0.7 });
        mesh = new THREE.Mesh(geo, mat);
        mesh.userData.moving = true;
        mesh.userData.direction = Math.random() > 0.5 ? 1 : -1;
      } else if (type === 'sphere') {
        const geo = new THREE.SphereGeometry(0.7, 24, 24);
        const mat = new THREE.MeshPhysicalMaterial({ color: 0x00bcd4, roughness: 0.1, metalness: 0.8 });
        mesh = new THREE.Mesh(geo, mat);
      } else if (type === 'torus') {
        const geo = new THREE.TorusGeometry(0.6, 0.2, 16, 32);
        const mat = new THREE.MeshPhysicalMaterial({ color: 0x8bc34a, roughness: 0.3, metalness: 0.6 });
        mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = Math.PI / 2;
      } else if (type === 'cone') {
        const geo = new THREE.ConeGeometry(0.6, 1.5, 16);
        const mat = new THREE.MeshPhysicalMaterial({ color: 0xe91e63, roughness: 0.2, metalness: 0.5 });
        mesh = new THREE.Mesh(geo, mat);
      }
      return mesh;
    }

    // Goal
    function createGoal() {
      const geo = new THREE.TorusGeometry(0.7, 0.2, 16, 100);
      const mat = new THREE.MeshLambertMaterial({ color: 0x00e676 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = Math.PI / 2;
      return mesh;
    }

    // Game State
    let penguin, penguinBox, obstacles = [], goal, goalBox;
    let penguinPos = { x: 0, y: 0, z: 0 };
    let velocityY = 0;
    let isJumping = false;
    let gameOver = false;
    let frame = 0;
    let distance = 0;
    let started = false;

    function randomObstacleType() {
      const types = ['block', 'cylinder', 'moving', 'sphere', 'torus', 'cone'];
      return types[Math.floor(Math.random() * types.length)];
    }

    function randomColor() {
      const colors = [0xff5252, 0xffb300, 0x7e57c2, 0x00bcd4, 0x8bc34a, 0xe91e63, 0x00e676];
      return colors[Math.floor(Math.random() * colors.length)];
    }

    function resetGame() {
      // Remove old objects
      if (penguin) scene.remove(penguin);
      obstacles.forEach(o => scene.remove(o));
      if (goal) scene.remove(goal);
      // Penguin
      penguin = createPenguin();
      penguin.position.set(0, 0, 0);
      scene.add(penguin);
      penguinPos = { x: 0, y: 0, z: 0 };
      velocityY = 0;
      isJumping = false;
      // Obstacles
      obstacles = [];
      for (let i = 1; i <= 12; i++) {
        let type = randomObstacleType();
        let color = randomColor();
        const obs = createObstacle(type, color);
        obs.position.set(
          (Math.random() - 0.5) * 14,
          0,
          -i * 10 - Math.random() * 3
        );
        if (type === 'moving') {
          obs.userData.baseX = obs.position.x;
        }
        scene.add(obs);
        obstacles.push(obs);
      }
      // Goal is not used in endless mode
      goal = null;
      // Boxes for collision
      penguinBox = new THREE.Box3();
      goalBox = new THREE.Box3();
      gameOver = false;
      frame = 0;
      distance = 0;
      started = false;
      document.getElementById('gameStatus').textContent = '';
      document.getElementById('restartBtn').classList.add('hidden');
      document.getElementById('hint').style.opacity = 1;
    }

    // Controls
    const keys = { left: false, right: false, up: false };
    window.addEventListener('keydown', e => {
      if (gameOver) return;
      if (!started && (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp')) {
        started = true;
        document.getElementById('hint').style.opacity = 0;
      }
      if (e.key === 'ArrowLeft') keys.left = true;
      if (e.key === 'ArrowRight') keys.right = true;
      if (e.key === 'ArrowUp') keys.up = true;
    });
    window.addEventListener('keyup', e => {
      if (e.key === 'ArrowLeft') keys.left = false;
      if (e.key === 'ArrowRight') keys.right = false;
      if (e.key === 'ArrowUp') keys.up = false;
    });

    // Game Loop
    function animate() {
      if (!gameOver) {
        // Animate ground wave
        animateGroundWave(frame);
        // Move penguin
        if (keys.left) penguinPos.x -= 0.18;
        if (keys.right) penguinPos.x += 0.18;
        // Jump
        if (keys.up && !isJumping) {
          velocityY = 0.38;
          isJumping = true;
          penguin.userData.jumpAnim = 1.0;
          playJumpSound();
        }
        // Gravity
        velocityY -= 0.018;
        penguinPos.y += velocityY;
        if (penguinPos.y < 0) {
          penguinPos.y = 0;
          velocityY = 0;
          isJumping = false;
          penguin.userData.squish = 1.0;
        }
        // Move forward
        penguinPos.z -= 0.22;
        distance = Math.max(distance, -penguinPos.z);
        // Clamp
        penguinPos.x = Math.max(-10, Math.min(10, penguinPos.x));
        // Penguin jump and squish animation
        if (penguin.userData.jumpAnim > 0) {
          penguin.scale.y = 1.2 + Math.sin(penguin.userData.jumpAnim * Math.PI) * 0.2;
          penguin.userData.jumpAnim -= 0.08;
        } else if (penguin.userData.squish > 0) {
          penguin.scale.y = 0.8 + Math.sin(penguin.userData.squish * Math.PI) * 0.2;
          penguin.userData.squish -= 0.08;
        } else {
          penguin.scale.y = 1.0;
        }
        penguin.position.set(penguinPos.x, penguinPos.y, penguinPos.z);
        // Camera follows
        camera.position.z = penguinPos.z + 15;
        camera.position.x = penguinPos.x;
        camera.lookAt(penguinPos.x, 0, penguinPos.z - 5);
        // Move ground to follow penguin for endless effect
        ground.position.z = penguinPos.z - 90;
        // Move obstacles
        frame++;
        obstacles.forEach(obs => {
          // Animate moving obstacles
          if (obs.userData.moving) {
            obs.position.x = obs.userData.baseX + Math.sin((frame + obs.position.z * 10) * 0.03) * 2 * obs.userData.direction;
            obs.rotation.y += 0.04;
          }
          // Animate all obstacles: bounce and rotate
          obs.position.y = 0.5 + Math.sin(frame * 0.07 + obs.position.z) * 0.18;
          obs.rotation.x += 0.01 + Math.random() * 0.01;
          // Color shift for fun
          if (obs.material && obs.material.color) {
            const base = obs.material.color.getHex();
            obs.material.color.offsetHSL(0.001, 0, 0);
          }
        });
        // Remove passed obstacles and add new ones
        obstacles = obstacles.filter(obs => {
          if (obs.position.z > penguinPos.z + 5) {
            scene.remove(obs);
            return false;
          }
          return true;
        });
        while (obstacles.length < 12) {
          let lastZ = obstacles.length > 0 ? Math.min(...obstacles.map(o => o.position.z)) : penguinPos.z - 10;
          let type = randomObstacleType();
          let color = randomColor();
          const obs = createObstacle(type, color);
          obs.position.set(
            (Math.random() - 0.5) * 14,
            0,
            lastZ - 10 - Math.random() * 3
          );
          if (type === 'moving') {
            obs.userData.baseX = obs.position.x;
          }
          scene.add(obs);
          obstacles.push(obs);
        }
        // Collision
        penguinBox.setFromObject(penguin);
        let hit = false;
        for (let obs of obstacles) {
          const obsBox = new THREE.Box3().setFromObject(obs);
          if (penguinBox.intersectsBox(obsBox)) {
            hit = true;
            // Particle burst effect on collision
            if (!obs.userData.burst) {
              obs.userData.burst = true;
              createParticleBurst(penguin.position);
            }
            break;
          }
        }
        if (hit) {
          gameOver = true;
          document.getElementById('gameStatus').textContent = `Game Over! Distance: ${Math.floor(distance)}m`;
          document.getElementById('restartBtn').classList.remove('hidden');
          playCrashSound();
          startScreenShake();
        } else {
          document.getElementById('gameStatus').textContent = `Distance: ${Math.floor(distance)}m`;
        }
      }
      renderer.render(scene, camera);
              // Screen shake effect
              if (screenShakeFrames > 0) {
                const shake = (Math.random() - 0.5) * 0.6 * screenShakeFrames / 10;
                camera.position.x += shake;
                camera.position.y += shake * 0.5;
                screenShakeFrames--;
              }
        // Animate particles
        animateParticles();
      requestAnimationFrame(animate);
    }

    // Responsive

    // --- Sound and feedback ---
    let screenShakeFrames = 0;
    function startScreenShake() {
      screenShakeFrames = 15;
    }
    function playJumpSound() {
      const audio = new Audio('https://cdn.pixabay.com/audio/2022/07/26/audio_124bfa4b7b.mp3');
      audio.volume = 0.2;
      audio.play();
    }
    function playCrashSound() {
      const audio = new Audio('https://cdn.pixabay.com/audio/2022/03/15/audio_115b9b273b.mp3');
      audio.volume = 0.3;
      audio.play();
    }

        // --- Particle burst effect ---
        let particles = [];
        function createParticleBurst(pos) {
          for (let i = 0; i < 32; i++) {
            const geo = new THREE.SphereGeometry(0.06, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff * Math.random() });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            mesh.userData = {
              vx: (Math.random() - 0.5) * 0.7,
              vy: Math.random() * 0.7,
              vz: (Math.random() - 0.5) * 0.7,
              life: 30 + Math.random() * 20
            };
            scene.add(mesh);
            particles.push(mesh);
          }
        }
        function animateParticles() {
          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.position.x += p.userData.vx;
            p.position.y += p.userData.vy;
            p.position.z += p.userData.vz;
            p.userData.vy -= 0.03;
            p.userData.life--;
            p.material.opacity = Math.max(0, p.userData.life / 50);
            p.material.transparent = true;
            if (p.userData.life <= 0) {
              scene.remove(p);
              particles.splice(i, 1);
            }
          }
        }
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Mobile touch controls (buttons + slide)
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');
    const btnJump = document.getElementById('btnJump');

    function bindHold(btn, onDown, onUp) {
      const down = e => { e.preventDefault(); onDown(); };
      const up = e => { e.preventDefault(); onUp(); };
      btn.addEventListener('touchstart', down, { passive: false });
      btn.addEventListener('touchend', up, { passive: false });
      btn.addEventListener('mousedown', down);
      btn.addEventListener('mouseup', up);
      btn.addEventListener('mouseleave', up);
    }

    bindHold(btnLeft, () => { keys.left = true; }, () => { keys.left = false; });
    bindHold(btnRight, () => { keys.right = true; }, () => { keys.right = false; });
    bindHold(btnJump, () => { keys.up = true; }, () => { keys.up = false; });

    // Slide on canvas: drag left/right to move, quick up swipe to jump
    let touchActive = false;
    let lastTouchX = 0;
    let lastTouchY = 0;
    let lastTouchTime = 0;
    canvas.addEventListener('touchstart', e => {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      touchActive = true;
      lastTouchX = t.clientX;
      lastTouchY = t.clientY;
      lastTouchTime = performance.now();
    }, { passive: true });

    canvas.addEventListener('touchmove', e => {
      if (!touchActive || e.touches.length !== 1) return;
      const t = e.touches[0];
      const dx = t.clientX - lastTouchX;
      const dy = t.clientY - lastTouchY;
      const now = performance.now();
      const dt = Math.max(1, now - lastTouchTime);
      // Horizontal slide controls
      if (Math.abs(dx) > 2) {
        penguinPos.x += dx * 0.05;
        penguinPos.x = Math.max(-10, Math.min(10, penguinPos.x));
      }
      // Up swipe for jump
      if (dy < -30 && dt < 200) {
        keys.up = true;
        setTimeout(() => { keys.up = false; }, 120);
      }
      lastTouchX = t.clientX;
      lastTouchY = t.clientY;
      lastTouchTime = now;
    }, { passive: true });

    canvas.addEventListener('touchend', () => {
      touchActive = false;
    }, { passive: true });

    // Restart
    document.getElementById('restartBtn').onclick = resetGame;

    // Start
    resetGame();
    animate();
  </script>
</body>
</html>
